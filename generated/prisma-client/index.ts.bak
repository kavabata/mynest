// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  controller: (where?: ControllerWhereInput) => Promise<boolean>;
  controllersState: (where?: ControllersStateWhereInput) => Promise<boolean>;
  device: (where?: DeviceWhereInput) => Promise<boolean>;
  mode: (where?: ModeWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  roomsDevice: (where?: RoomsDeviceWhereInput) => Promise<boolean>;
  scenario: (where?: ScenarioWhereInput) => Promise<boolean>;
  sensor: (where?: SensorWhereInput) => Promise<boolean>;
  sensorsLog: (where?: SensorsLogWhereInput) => Promise<boolean>;
  sensorsState: (where?: SensorsStateWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  controller: (where: ControllerWhereUniqueInput) => ControllerNullablePromise;
  controllers: (args?: {
    where?: ControllerWhereInput;
    orderBy?: ControllerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Controller>;
  controllersConnection: (args?: {
    where?: ControllerWhereInput;
    orderBy?: ControllerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ControllerConnectionPromise;
  controllersState: (
    where: ControllersStateWhereUniqueInput
  ) => ControllersStateNullablePromise;
  controllersStates: (args?: {
    where?: ControllersStateWhereInput;
    orderBy?: ControllersStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ControllersState>;
  controllersStatesConnection: (args?: {
    where?: ControllersStateWhereInput;
    orderBy?: ControllersStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ControllersStateConnectionPromise;
  device: (where: DeviceWhereUniqueInput) => DeviceNullablePromise;
  devices: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Device>;
  devicesConnection: (args?: {
    where?: DeviceWhereInput;
    orderBy?: DeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DeviceConnectionPromise;
  mode: (where: ModeWhereUniqueInput) => ModeNullablePromise;
  modes: (args?: {
    where?: ModeWhereInput;
    orderBy?: ModeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Mode>;
  modesConnection: (args?: {
    where?: ModeWhereInput;
    orderBy?: ModeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ModeConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  roomsDevice: (
    where: RoomsDeviceWhereUniqueInput
  ) => RoomsDeviceNullablePromise;
  roomsDevices: (args?: {
    where?: RoomsDeviceWhereInput;
    orderBy?: RoomsDeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RoomsDevice>;
  roomsDevicesConnection: (args?: {
    where?: RoomsDeviceWhereInput;
    orderBy?: RoomsDeviceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomsDeviceConnectionPromise;
  scenario: (where: ScenarioWhereUniqueInput) => ScenarioNullablePromise;
  scenarios: (args?: {
    where?: ScenarioWhereInput;
    orderBy?: ScenarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Scenario>;
  scenariosConnection: (args?: {
    where?: ScenarioWhereInput;
    orderBy?: ScenarioOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ScenarioConnectionPromise;
  sensor: (where: SensorWhereUniqueInput) => SensorNullablePromise;
  sensors: (args?: {
    where?: SensorWhereInput;
    orderBy?: SensorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sensor>;
  sensorsConnection: (args?: {
    where?: SensorWhereInput;
    orderBy?: SensorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SensorConnectionPromise;
  sensorsLog: (where: SensorsLogWhereUniqueInput) => SensorsLogNullablePromise;
  sensorsLogs: (args?: {
    where?: SensorsLogWhereInput;
    orderBy?: SensorsLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SensorsLog>;
  sensorsLogsConnection: (args?: {
    where?: SensorsLogWhereInput;
    orderBy?: SensorsLogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SensorsLogConnectionPromise;
  sensorsState: (
    where: SensorsStateWhereUniqueInput
  ) => SensorsStateNullablePromise;
  sensorsStates: (args?: {
    where?: SensorsStateWhereInput;
    orderBy?: SensorsStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SensorsState>;
  sensorsStatesConnection: (args?: {
    where?: SensorsStateWhereInput;
    orderBy?: SensorsStateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SensorsStateConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createController: (data: ControllerCreateInput) => ControllerPromise;
  updateController: (args: {
    data: ControllerUpdateInput;
    where: ControllerWhereUniqueInput;
  }) => ControllerPromise;
  updateManyControllers: (args: {
    data: ControllerUpdateManyMutationInput;
    where?: ControllerWhereInput;
  }) => BatchPayloadPromise;
  upsertController: (args: {
    where: ControllerWhereUniqueInput;
    create: ControllerCreateInput;
    update: ControllerUpdateInput;
  }) => ControllerPromise;
  deleteController: (where: ControllerWhereUniqueInput) => ControllerPromise;
  deleteManyControllers: (where?: ControllerWhereInput) => BatchPayloadPromise;
  createControllersState: (
    data: ControllersStateCreateInput
  ) => ControllersStatePromise;
  updateControllersState: (args: {
    data: ControllersStateUpdateInput;
    where: ControllersStateWhereUniqueInput;
  }) => ControllersStatePromise;
  updateManyControllersStates: (args: {
    data: ControllersStateUpdateManyMutationInput;
    where?: ControllersStateWhereInput;
  }) => BatchPayloadPromise;
  upsertControllersState: (args: {
    where: ControllersStateWhereUniqueInput;
    create: ControllersStateCreateInput;
    update: ControllersStateUpdateInput;
  }) => ControllersStatePromise;
  deleteControllersState: (
    where: ControllersStateWhereUniqueInput
  ) => ControllersStatePromise;
  deleteManyControllersStates: (
    where?: ControllersStateWhereInput
  ) => BatchPayloadPromise;
  createDevice: (data: DeviceCreateInput) => DevicePromise;
  updateDevice: (args: {
    data: DeviceUpdateInput;
    where: DeviceWhereUniqueInput;
  }) => DevicePromise;
  updateManyDevices: (args: {
    data: DeviceUpdateManyMutationInput;
    where?: DeviceWhereInput;
  }) => BatchPayloadPromise;
  upsertDevice: (args: {
    where: DeviceWhereUniqueInput;
    create: DeviceCreateInput;
    update: DeviceUpdateInput;
  }) => DevicePromise;
  deleteDevice: (where: DeviceWhereUniqueInput) => DevicePromise;
  deleteManyDevices: (where?: DeviceWhereInput) => BatchPayloadPromise;
  createMode: (data: ModeCreateInput) => ModePromise;
  updateMode: (args: {
    data: ModeUpdateInput;
    where: ModeWhereUniqueInput;
  }) => ModePromise;
  updateManyModes: (args: {
    data: ModeUpdateManyMutationInput;
    where?: ModeWhereInput;
  }) => BatchPayloadPromise;
  upsertMode: (args: {
    where: ModeWhereUniqueInput;
    create: ModeCreateInput;
    update: ModeUpdateInput;
  }) => ModePromise;
  deleteMode: (where: ModeWhereUniqueInput) => ModePromise;
  deleteManyModes: (where?: ModeWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createRoomsDevice: (data: RoomsDeviceCreateInput) => RoomsDevicePromise;
  updateRoomsDevice: (args: {
    data: RoomsDeviceUpdateInput;
    where: RoomsDeviceWhereUniqueInput;
  }) => RoomsDevicePromise;
  updateManyRoomsDevices: (args: {
    data: RoomsDeviceUpdateManyMutationInput;
    where?: RoomsDeviceWhereInput;
  }) => BatchPayloadPromise;
  upsertRoomsDevice: (args: {
    where: RoomsDeviceWhereUniqueInput;
    create: RoomsDeviceCreateInput;
    update: RoomsDeviceUpdateInput;
  }) => RoomsDevicePromise;
  deleteRoomsDevice: (where: RoomsDeviceWhereUniqueInput) => RoomsDevicePromise;
  deleteManyRoomsDevices: (
    where?: RoomsDeviceWhereInput
  ) => BatchPayloadPromise;
  createScenario: (data: ScenarioCreateInput) => ScenarioPromise;
  updateScenario: (args: {
    data: ScenarioUpdateInput;
    where: ScenarioWhereUniqueInput;
  }) => ScenarioPromise;
  updateManyScenarios: (args: {
    data: ScenarioUpdateManyMutationInput;
    where?: ScenarioWhereInput;
  }) => BatchPayloadPromise;
  upsertScenario: (args: {
    where: ScenarioWhereUniqueInput;
    create: ScenarioCreateInput;
    update: ScenarioUpdateInput;
  }) => ScenarioPromise;
  deleteScenario: (where: ScenarioWhereUniqueInput) => ScenarioPromise;
  deleteManyScenarios: (where?: ScenarioWhereInput) => BatchPayloadPromise;
  createSensor: (data: SensorCreateInput) => SensorPromise;
  updateSensor: (args: {
    data: SensorUpdateInput;
    where: SensorWhereUniqueInput;
  }) => SensorPromise;
  updateManySensors: (args: {
    data: SensorUpdateManyMutationInput;
    where?: SensorWhereInput;
  }) => BatchPayloadPromise;
  upsertSensor: (args: {
    where: SensorWhereUniqueInput;
    create: SensorCreateInput;
    update: SensorUpdateInput;
  }) => SensorPromise;
  deleteSensor: (where: SensorWhereUniqueInput) => SensorPromise;
  deleteManySensors: (where?: SensorWhereInput) => BatchPayloadPromise;
  createSensorsLog: (data: SensorsLogCreateInput) => SensorsLogPromise;
  updateSensorsLog: (args: {
    data: SensorsLogUpdateInput;
    where: SensorsLogWhereUniqueInput;
  }) => SensorsLogPromise;
  updateManySensorsLogs: (args: {
    data: SensorsLogUpdateManyMutationInput;
    where?: SensorsLogWhereInput;
  }) => BatchPayloadPromise;
  upsertSensorsLog: (args: {
    where: SensorsLogWhereUniqueInput;
    create: SensorsLogCreateInput;
    update: SensorsLogUpdateInput;
  }) => SensorsLogPromise;
  deleteSensorsLog: (where: SensorsLogWhereUniqueInput) => SensorsLogPromise;
  deleteManySensorsLogs: (where?: SensorsLogWhereInput) => BatchPayloadPromise;
  createSensorsState: (data: SensorsStateCreateInput) => SensorsStatePromise;
  updateSensorsState: (args: {
    data: SensorsStateUpdateInput;
    where: SensorsStateWhereUniqueInput;
  }) => SensorsStatePromise;
  updateManySensorsStates: (args: {
    data: SensorsStateUpdateManyMutationInput;
    where?: SensorsStateWhereInput;
  }) => BatchPayloadPromise;
  upsertSensorsState: (args: {
    where: SensorsStateWhereUniqueInput;
    create: SensorsStateCreateInput;
    update: SensorsStateUpdateInput;
  }) => SensorsStatePromise;
  deleteSensorsState: (
    where: SensorsStateWhereUniqueInput
  ) => SensorsStatePromise;
  deleteManySensorsStates: (
    where?: SensorsStateWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  controller: (
    where?: ControllerSubscriptionWhereInput
  ) => ControllerSubscriptionPayloadSubscription;
  controllersState: (
    where?: ControllersStateSubscriptionWhereInput
  ) => ControllersStateSubscriptionPayloadSubscription;
  device: (
    where?: DeviceSubscriptionWhereInput
  ) => DeviceSubscriptionPayloadSubscription;
  mode: (
    where?: ModeSubscriptionWhereInput
  ) => ModeSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  roomsDevice: (
    where?: RoomsDeviceSubscriptionWhereInput
  ) => RoomsDeviceSubscriptionPayloadSubscription;
  scenario: (
    where?: ScenarioSubscriptionWhereInput
  ) => ScenarioSubscriptionPayloadSubscription;
  sensor: (
    where?: SensorSubscriptionWhereInput
  ) => SensorSubscriptionPayloadSubscription;
  sensorsLog: (
    where?: SensorsLogSubscriptionWhereInput
  ) => SensorsLogSubscriptionPayloadSubscription;
  sensorsState: (
    where?: SensorsStateSubscriptionWhereInput
  ) => SensorsStateSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ControllerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "controller_ASC"
  | "controller_DESC"
  | "controllerDefault_ASC"
  | "controllerDefault_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "modeId_ASC"
  | "modeId_DESC"
  | "name_ASC"
  | "name_DESC";

export type ControllersStateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "controllerId_ASC"
  | "controllerId_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "state_ASC"
  | "state_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type DeviceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_ASC"
  | "created_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "key_ASC"
  | "key_DESC"
  | "name_ASC"
  | "name_DESC"
  | "status_ASC"
  | "status_DESC";

export type ModeOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "modeId_ASC"
  | "modeId_DESC"
  | "modeUpdated_ASC"
  | "modeUpdated_DESC"
  | "name_ASC"
  | "name_DESC";

export type RoomsDeviceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "roomId_ASC"
  | "roomId_DESC";

export type ScenarioOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "controllerDelay_ASC"
  | "controllerDelay_DESC"
  | "controllerId_ASC"
  | "controllerId_DESC"
  | "controllerValue_ASC"
  | "controllerValue_DESC"
  | "modeId_ASC"
  | "modeId_DESC"
  | "sensorEnd_ASC"
  | "sensorEnd_DESC"
  | "sensorId_ASC"
  | "sensorId_DESC"
  | "sensorStart_ASC"
  | "sensorStart_DESC"
  | "sortOrder_ASC"
  | "sortOrder_DESC";

export type SensorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "roomId_ASC"
  | "roomId_DESC"
  | "sensorDelay_ASC"
  | "sensorDelay_DESC"
  | "type_ASC"
  | "type_DESC";

export type SensorsLogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "created_ASC"
  | "created_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "roomId_ASC"
  | "roomId_DESC"
  | "sensorId_ASC"
  | "sensorId_DESC"
  | "value_ASC"
  | "value_DESC";

export type SensorsStateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "deviceId_ASC"
  | "deviceId_DESC"
  | "roomId_ASC"
  | "roomId_DESC"
  | "sensorId_ASC"
  | "sensorId_DESC"
  | "updated_ASC"
  | "updated_DESC"
  | "value_ASC"
  | "value_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ControllerWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ControllerWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  controller?: Maybe<String>;
  controller_not?: Maybe<String>;
  controller_in?: Maybe<String[] | String>;
  controller_not_in?: Maybe<String[] | String>;
  controller_lt?: Maybe<String>;
  controller_lte?: Maybe<String>;
  controller_gt?: Maybe<String>;
  controller_gte?: Maybe<String>;
  controller_contains?: Maybe<String>;
  controller_not_contains?: Maybe<String>;
  controller_starts_with?: Maybe<String>;
  controller_not_starts_with?: Maybe<String>;
  controller_ends_with?: Maybe<String>;
  controller_not_ends_with?: Maybe<String>;
  controllerDefault?: Maybe<Float>;
  controllerDefault_not?: Maybe<Float>;
  controllerDefault_in?: Maybe<Float[] | Float>;
  controllerDefault_not_in?: Maybe<Float[] | Float>;
  controllerDefault_lt?: Maybe<Float>;
  controllerDefault_lte?: Maybe<Float>;
  controllerDefault_gt?: Maybe<Float>;
  controllerDefault_gte?: Maybe<Float>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  modeId?: Maybe<Int>;
  modeId_not?: Maybe<Int>;
  modeId_in?: Maybe<Int[] | Int>;
  modeId_not_in?: Maybe<Int[] | Int>;
  modeId_lt?: Maybe<Int>;
  modeId_lte?: Maybe<Int>;
  modeId_gt?: Maybe<Int>;
  modeId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ControllerWhereInput[] | ControllerWhereInput>;
  OR?: Maybe<ControllerWhereInput[] | ControllerWhereInput>;
  NOT?: Maybe<ControllerWhereInput[] | ControllerWhereInput>;
}

export type ControllersStateWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ControllersStateWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  controllerId_not?: Maybe<Int>;
  controllerId_in?: Maybe<Int[] | Int>;
  controllerId_not_in?: Maybe<Int[] | Int>;
  controllerId_lt?: Maybe<Int>;
  controllerId_lte?: Maybe<Int>;
  controllerId_gt?: Maybe<Int>;
  controllerId_gte?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ControllersStateWhereInput[] | ControllersStateWhereInput>;
  OR?: Maybe<ControllersStateWhereInput[] | ControllersStateWhereInput>;
  NOT?: Maybe<ControllersStateWhereInput[] | ControllersStateWhereInput>;
}

export type DeviceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface DeviceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  OR?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
  NOT?: Maybe<DeviceWhereInput[] | DeviceWhereInput>;
}

export type ModeWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ModeWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ModeWhereInput[] | ModeWhereInput>;
  OR?: Maybe<ModeWhereInput[] | ModeWhereInput>;
  NOT?: Maybe<ModeWhereInput[] | ModeWhereInput>;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface RoomWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  modeId?: Maybe<Int>;
  modeId_not?: Maybe<Int>;
  modeId_in?: Maybe<Int[] | Int>;
  modeId_not_in?: Maybe<Int[] | Int>;
  modeId_lt?: Maybe<Int>;
  modeId_lte?: Maybe<Int>;
  modeId_gt?: Maybe<Int>;
  modeId_gte?: Maybe<Int>;
  modeUpdated?: Maybe<DateTimeInput>;
  modeUpdated_not?: Maybe<DateTimeInput>;
  modeUpdated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modeUpdated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modeUpdated_lt?: Maybe<DateTimeInput>;
  modeUpdated_lte?: Maybe<DateTimeInput>;
  modeUpdated_gt?: Maybe<DateTimeInput>;
  modeUpdated_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export type RoomsDeviceWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface RoomsDeviceWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  roomId?: Maybe<Int>;
  roomId_not?: Maybe<Int>;
  roomId_in?: Maybe<Int[] | Int>;
  roomId_not_in?: Maybe<Int[] | Int>;
  roomId_lt?: Maybe<Int>;
  roomId_lte?: Maybe<Int>;
  roomId_gt?: Maybe<Int>;
  roomId_gte?: Maybe<Int>;
  AND?: Maybe<RoomsDeviceWhereInput[] | RoomsDeviceWhereInput>;
  OR?: Maybe<RoomsDeviceWhereInput[] | RoomsDeviceWhereInput>;
  NOT?: Maybe<RoomsDeviceWhereInput[] | RoomsDeviceWhereInput>;
}

export type ScenarioWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface ScenarioWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  controllerDelay?: Maybe<Int>;
  controllerDelay_not?: Maybe<Int>;
  controllerDelay_in?: Maybe<Int[] | Int>;
  controllerDelay_not_in?: Maybe<Int[] | Int>;
  controllerDelay_lt?: Maybe<Int>;
  controllerDelay_lte?: Maybe<Int>;
  controllerDelay_gt?: Maybe<Int>;
  controllerDelay_gte?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  controllerId_not?: Maybe<Int>;
  controllerId_in?: Maybe<Int[] | Int>;
  controllerId_not_in?: Maybe<Int[] | Int>;
  controllerId_lt?: Maybe<Int>;
  controllerId_lte?: Maybe<Int>;
  controllerId_gt?: Maybe<Int>;
  controllerId_gte?: Maybe<Int>;
  controllerValue?: Maybe<Int>;
  controllerValue_not?: Maybe<Int>;
  controllerValue_in?: Maybe<Int[] | Int>;
  controllerValue_not_in?: Maybe<Int[] | Int>;
  controllerValue_lt?: Maybe<Int>;
  controllerValue_lte?: Maybe<Int>;
  controllerValue_gt?: Maybe<Int>;
  controllerValue_gte?: Maybe<Int>;
  modeId?: Maybe<Int>;
  modeId_not?: Maybe<Int>;
  modeId_in?: Maybe<Int[] | Int>;
  modeId_not_in?: Maybe<Int[] | Int>;
  modeId_lt?: Maybe<Int>;
  modeId_lte?: Maybe<Int>;
  modeId_gt?: Maybe<Int>;
  modeId_gte?: Maybe<Int>;
  sensorEnd?: Maybe<Float>;
  sensorEnd_not?: Maybe<Float>;
  sensorEnd_in?: Maybe<Float[] | Float>;
  sensorEnd_not_in?: Maybe<Float[] | Float>;
  sensorEnd_lt?: Maybe<Float>;
  sensorEnd_lte?: Maybe<Float>;
  sensorEnd_gt?: Maybe<Float>;
  sensorEnd_gte?: Maybe<Float>;
  sensorId?: Maybe<Int>;
  sensorId_not?: Maybe<Int>;
  sensorId_in?: Maybe<Int[] | Int>;
  sensorId_not_in?: Maybe<Int[] | Int>;
  sensorId_lt?: Maybe<Int>;
  sensorId_lte?: Maybe<Int>;
  sensorId_gt?: Maybe<Int>;
  sensorId_gte?: Maybe<Int>;
  sensorStart?: Maybe<Float>;
  sensorStart_not?: Maybe<Float>;
  sensorStart_in?: Maybe<Float[] | Float>;
  sensorStart_not_in?: Maybe<Float[] | Float>;
  sensorStart_lt?: Maybe<Float>;
  sensorStart_lte?: Maybe<Float>;
  sensorStart_gt?: Maybe<Float>;
  sensorStart_gte?: Maybe<Float>;
  sortOrder?: Maybe<Int>;
  sortOrder_not?: Maybe<Int>;
  sortOrder_in?: Maybe<Int[] | Int>;
  sortOrder_not_in?: Maybe<Int[] | Int>;
  sortOrder_lt?: Maybe<Int>;
  sortOrder_lte?: Maybe<Int>;
  sortOrder_gt?: Maybe<Int>;
  sortOrder_gte?: Maybe<Int>;
  AND?: Maybe<ScenarioWhereInput[] | ScenarioWhereInput>;
  OR?: Maybe<ScenarioWhereInput[] | ScenarioWhereInput>;
  NOT?: Maybe<ScenarioWhereInput[] | ScenarioWhereInput>;
}

export type SensorWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SensorWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  roomId?: Maybe<Int>;
  roomId_not?: Maybe<Int>;
  roomId_in?: Maybe<Int[] | Int>;
  roomId_not_in?: Maybe<Int[] | Int>;
  roomId_lt?: Maybe<Int>;
  roomId_lte?: Maybe<Int>;
  roomId_gt?: Maybe<Int>;
  roomId_gte?: Maybe<Int>;
  sensorDelay?: Maybe<Int>;
  sensorDelay_not?: Maybe<Int>;
  sensorDelay_in?: Maybe<Int[] | Int>;
  sensorDelay_not_in?: Maybe<Int[] | Int>;
  sensorDelay_lt?: Maybe<Int>;
  sensorDelay_lte?: Maybe<Int>;
  sensorDelay_gt?: Maybe<Int>;
  sensorDelay_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<SensorWhereInput[] | SensorWhereInput>;
  OR?: Maybe<SensorWhereInput[] | SensorWhereInput>;
  NOT?: Maybe<SensorWhereInput[] | SensorWhereInput>;
}

export type SensorsLogWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SensorsLogWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  created_not?: Maybe<DateTimeInput>;
  created_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  created_lt?: Maybe<DateTimeInput>;
  created_lte?: Maybe<DateTimeInput>;
  created_gt?: Maybe<DateTimeInput>;
  created_gte?: Maybe<DateTimeInput>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  roomId?: Maybe<Int>;
  roomId_not?: Maybe<Int>;
  roomId_in?: Maybe<Int[] | Int>;
  roomId_not_in?: Maybe<Int[] | Int>;
  roomId_lt?: Maybe<Int>;
  roomId_lte?: Maybe<Int>;
  roomId_gt?: Maybe<Int>;
  roomId_gte?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  sensorId_not?: Maybe<Int>;
  sensorId_in?: Maybe<Int[] | Int>;
  sensorId_not_in?: Maybe<Int[] | Int>;
  sensorId_lt?: Maybe<Int>;
  sensorId_lte?: Maybe<Int>;
  sensorId_gt?: Maybe<Int>;
  sensorId_gte?: Maybe<Int>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<SensorsLogWhereInput[] | SensorsLogWhereInput>;
  OR?: Maybe<SensorsLogWhereInput[] | SensorsLogWhereInput>;
  NOT?: Maybe<SensorsLogWhereInput[] | SensorsLogWhereInput>;
}

export type SensorsStateWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface SensorsStateWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  deviceId_not?: Maybe<Int>;
  deviceId_in?: Maybe<Int[] | Int>;
  deviceId_not_in?: Maybe<Int[] | Int>;
  deviceId_lt?: Maybe<Int>;
  deviceId_lte?: Maybe<Int>;
  deviceId_gt?: Maybe<Int>;
  deviceId_gte?: Maybe<Int>;
  roomId?: Maybe<Int>;
  roomId_not?: Maybe<Int>;
  roomId_in?: Maybe<Int[] | Int>;
  roomId_not_in?: Maybe<Int[] | Int>;
  roomId_lt?: Maybe<Int>;
  roomId_lte?: Maybe<Int>;
  roomId_gt?: Maybe<Int>;
  roomId_gte?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  sensorId_not?: Maybe<Int>;
  sensorId_in?: Maybe<Int[] | Int>;
  sensorId_not_in?: Maybe<Int[] | Int>;
  sensorId_lt?: Maybe<Int>;
  sensorId_lte?: Maybe<Int>;
  sensorId_gt?: Maybe<Int>;
  sensorId_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
  value_not?: Maybe<String>;
  value_in?: Maybe<String[] | String>;
  value_not_in?: Maybe<String[] | String>;
  value_lt?: Maybe<String>;
  value_lte?: Maybe<String>;
  value_gt?: Maybe<String>;
  value_gte?: Maybe<String>;
  value_contains?: Maybe<String>;
  value_not_contains?: Maybe<String>;
  value_starts_with?: Maybe<String>;
  value_not_starts_with?: Maybe<String>;
  value_ends_with?: Maybe<String>;
  value_not_ends_with?: Maybe<String>;
  AND?: Maybe<SensorsStateWhereInput[] | SensorsStateWhereInput>;
  OR?: Maybe<SensorsStateWhereInput[] | SensorsStateWhereInput>;
  NOT?: Maybe<SensorsStateWhereInput[] | SensorsStateWhereInput>;
}

export interface ControllerCreateInput {
  id?: Maybe<Int>;
  controller?: Maybe<String>;
  controllerDefault?: Maybe<Float>;
  deviceId?: Maybe<Int>;
  modeId?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface ControllerUpdateInput {
  controller?: Maybe<String>;
  controllerDefault?: Maybe<Float>;
  deviceId?: Maybe<Int>;
  modeId?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface ControllerUpdateManyMutationInput {
  controller?: Maybe<String>;
  controllerDefault?: Maybe<Float>;
  deviceId?: Maybe<Int>;
  modeId?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface ControllersStateCreateInput {
  id?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  state?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
}

export interface ControllersStateUpdateInput {
  controllerId?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  state?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
}

export interface ControllersStateUpdateManyMutationInput {
  controllerId?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  state?: Maybe<String>;
  updated?: Maybe<DateTimeInput>;
}

export interface DeviceCreateInput {
  id?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  ip?: Maybe<String>;
  key?: Maybe<String>;
  name?: Maybe<String>;
  status?: Maybe<String>;
}

export interface DeviceUpdateInput {
  created?: Maybe<DateTimeInput>;
  ip?: Maybe<String>;
  key?: Maybe<String>;
  name?: Maybe<String>;
  status?: Maybe<String>;
}

export interface DeviceUpdateManyMutationInput {
  created?: Maybe<DateTimeInput>;
  ip?: Maybe<String>;
  key?: Maybe<String>;
  name?: Maybe<String>;
  status?: Maybe<String>;
}

export interface ModeCreateInput {
  id?: Maybe<Int>;
  name?: Maybe<String>;
}

export interface ModeUpdateInput {
  name?: Maybe<String>;
}

export interface ModeUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface RoomCreateInput {
  id?: Maybe<Int>;
  modeId?: Maybe<Int>;
  modeUpdated?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
}

export interface RoomUpdateInput {
  modeId?: Maybe<Int>;
  modeUpdated?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
}

export interface RoomUpdateManyMutationInput {
  modeId?: Maybe<Int>;
  modeUpdated?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
}

export interface RoomsDeviceCreateInput {
  id?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
}

export interface RoomsDeviceUpdateInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
}

export interface RoomsDeviceUpdateManyMutationInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
}

export interface ScenarioCreateInput {
  id?: Maybe<Int>;
  controllerDelay?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  controllerValue?: Maybe<Int>;
  modeId?: Maybe<Int>;
  sensorEnd?: Maybe<Float>;
  sensorId?: Maybe<Int>;
  sensorStart?: Maybe<Float>;
  sortOrder?: Maybe<Int>;
}

export interface ScenarioUpdateInput {
  controllerDelay?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  controllerValue?: Maybe<Int>;
  modeId?: Maybe<Int>;
  sensorEnd?: Maybe<Float>;
  sensorId?: Maybe<Int>;
  sensorStart?: Maybe<Float>;
  sortOrder?: Maybe<Int>;
}

export interface ScenarioUpdateManyMutationInput {
  controllerDelay?: Maybe<Int>;
  controllerId?: Maybe<Int>;
  controllerValue?: Maybe<Int>;
  modeId?: Maybe<Int>;
  sensorEnd?: Maybe<Float>;
  sensorId?: Maybe<Int>;
  sensorStart?: Maybe<Float>;
  sortOrder?: Maybe<Int>;
}

export interface SensorCreateInput {
  id?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorDelay?: Maybe<Int>;
  type?: Maybe<String>;
}

export interface SensorUpdateInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorDelay?: Maybe<Int>;
  type?: Maybe<String>;
}

export interface SensorUpdateManyMutationInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorDelay?: Maybe<Int>;
  type?: Maybe<String>;
}

export interface SensorsLogCreateInput {
  id?: Maybe<Int>;
  created?: Maybe<DateTimeInput>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  value?: Maybe<String>;
}

export interface SensorsLogUpdateInput {
  created?: Maybe<DateTimeInput>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  value?: Maybe<String>;
}

export interface SensorsLogUpdateManyMutationInput {
  created?: Maybe<DateTimeInput>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  value?: Maybe<String>;
}

export interface SensorsStateCreateInput {
  id?: Maybe<Int>;
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
}

export interface SensorsStateUpdateInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
}

export interface SensorsStateUpdateManyMutationInput {
  deviceId?: Maybe<Int>;
  roomId?: Maybe<Int>;
  sensorId?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  value?: Maybe<String>;
}

export interface ControllerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ControllerWhereInput>;
  AND?: Maybe<
    ControllerSubscriptionWhereInput[] | ControllerSubscriptionWhereInput
  >;
  OR?: Maybe<
    ControllerSubscriptionWhereInput[] | ControllerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ControllerSubscriptionWhereInput[] | ControllerSubscriptionWhereInput
  >;
}

export interface ControllersStateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ControllersStateWhereInput>;
  AND?: Maybe<
    | ControllersStateSubscriptionWhereInput[]
    | ControllersStateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ControllersStateSubscriptionWhereInput[]
    | ControllersStateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ControllersStateSubscriptionWhereInput[]
    | ControllersStateSubscriptionWhereInput
  >;
}

export interface DeviceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DeviceWhereInput>;
  AND?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  OR?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
  NOT?: Maybe<DeviceSubscriptionWhereInput[] | DeviceSubscriptionWhereInput>;
}

export interface ModeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ModeWhereInput>;
  AND?: Maybe<ModeSubscriptionWhereInput[] | ModeSubscriptionWhereInput>;
  OR?: Maybe<ModeSubscriptionWhereInput[] | ModeSubscriptionWhereInput>;
  NOT?: Maybe<ModeSubscriptionWhereInput[] | ModeSubscriptionWhereInput>;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface RoomsDeviceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomsDeviceWhereInput>;
  AND?: Maybe<
    RoomsDeviceSubscriptionWhereInput[] | RoomsDeviceSubscriptionWhereInput
  >;
  OR?: Maybe<
    RoomsDeviceSubscriptionWhereInput[] | RoomsDeviceSubscriptionWhereInput
  >;
  NOT?: Maybe<
    RoomsDeviceSubscriptionWhereInput[] | RoomsDeviceSubscriptionWhereInput
  >;
}

export interface ScenarioSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ScenarioWhereInput>;
  AND?: Maybe<
    ScenarioSubscriptionWhereInput[] | ScenarioSubscriptionWhereInput
  >;
  OR?: Maybe<ScenarioSubscriptionWhereInput[] | ScenarioSubscriptionWhereInput>;
  NOT?: Maybe<
    ScenarioSubscriptionWhereInput[] | ScenarioSubscriptionWhereInput
  >;
}

export interface SensorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SensorWhereInput>;
  AND?: Maybe<SensorSubscriptionWhereInput[] | SensorSubscriptionWhereInput>;
  OR?: Maybe<SensorSubscriptionWhereInput[] | SensorSubscriptionWhereInput>;
  NOT?: Maybe<SensorSubscriptionWhereInput[] | SensorSubscriptionWhereInput>;
}

export interface SensorsLogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SensorsLogWhereInput>;
  AND?: Maybe<
    SensorsLogSubscriptionWhereInput[] | SensorsLogSubscriptionWhereInput
  >;
  OR?: Maybe<
    SensorsLogSubscriptionWhereInput[] | SensorsLogSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SensorsLogSubscriptionWhereInput[] | SensorsLogSubscriptionWhereInput
  >;
}

export interface SensorsStateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SensorsStateWhereInput>;
  AND?: Maybe<
    SensorsStateSubscriptionWhereInput[] | SensorsStateSubscriptionWhereInput
  >;
  OR?: Maybe<
    SensorsStateSubscriptionWhereInput[] | SensorsStateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SensorsStateSubscriptionWhereInput[] | SensorsStateSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Controller {
  id: Int;
  controller?: String;
  controllerDefault?: Float;
  deviceId?: Int;
  modeId: Int;
  name?: String;
}

export interface ControllerPromise extends Promise<Controller>, Fragmentable {
  id: () => Promise<Int>;
  controller: () => Promise<String>;
  controllerDefault: () => Promise<Float>;
  deviceId: () => Promise<Int>;
  modeId: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ControllerSubscription
  extends Promise<AsyncIterator<Controller>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controller: () => Promise<AsyncIterator<String>>;
  controllerDefault: () => Promise<AsyncIterator<Float>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ControllerNullablePromise
  extends Promise<Controller | null>,
    Fragmentable {
  id: () => Promise<Int>;
  controller: () => Promise<String>;
  controllerDefault: () => Promise<Float>;
  deviceId: () => Promise<Int>;
  modeId: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ControllerConnection {
  pageInfo: PageInfo;
  edges: ControllerEdge[];
}

export interface ControllerConnectionPromise
  extends Promise<ControllerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ControllerEdge>>() => T;
  aggregate: <T = AggregateControllerPromise>() => T;
}

export interface ControllerConnectionSubscription
  extends Promise<AsyncIterator<ControllerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ControllerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateControllerSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ControllerEdge {
  node: Controller;
  cursor: String;
}

export interface ControllerEdgePromise
  extends Promise<ControllerEdge>,
    Fragmentable {
  node: <T = ControllerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ControllerEdgeSubscription
  extends Promise<AsyncIterator<ControllerEdge>>,
    Fragmentable {
  node: <T = ControllerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateController {
  count: Int;
}

export interface AggregateControllerPromise
  extends Promise<AggregateController>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateControllerSubscription
  extends Promise<AsyncIterator<AggregateController>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ControllersState {
  id: Int;
  controllerId?: Int;
  deviceId?: Int;
  state?: String;
  updated?: DateTimeOutput;
}

export interface ControllersStatePromise
  extends Promise<ControllersState>,
    Fragmentable {
  id: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  state: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface ControllersStateSubscription
  extends Promise<AsyncIterator<ControllersState>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controllerId: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ControllersStateNullablePromise
  extends Promise<ControllersState | null>,
    Fragmentable {
  id: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  state: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface ControllersStateConnection {
  pageInfo: PageInfo;
  edges: ControllersStateEdge[];
}

export interface ControllersStateConnectionPromise
  extends Promise<ControllersStateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ControllersStateEdge>>() => T;
  aggregate: <T = AggregateControllersStatePromise>() => T;
}

export interface ControllersStateConnectionSubscription
  extends Promise<AsyncIterator<ControllersStateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ControllersStateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateControllersStateSubscription>() => T;
}

export interface ControllersStateEdge {
  node: ControllersState;
  cursor: String;
}

export interface ControllersStateEdgePromise
  extends Promise<ControllersStateEdge>,
    Fragmentable {
  node: <T = ControllersStatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ControllersStateEdgeSubscription
  extends Promise<AsyncIterator<ControllersStateEdge>>,
    Fragmentable {
  node: <T = ControllersStateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateControllersState {
  count: Int;
}

export interface AggregateControllersStatePromise
  extends Promise<AggregateControllersState>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateControllersStateSubscription
  extends Promise<AsyncIterator<AggregateControllersState>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Device {
  id: Int;
  created?: DateTimeOutput;
  ip?: String;
  key?: String;
  name?: String;
  status?: String;
}

export interface DevicePromise extends Promise<Device>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  ip: () => Promise<String>;
  key: () => Promise<String>;
  name: () => Promise<String>;
  status: () => Promise<String>;
}

export interface DeviceSubscription
  extends Promise<AsyncIterator<Device>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  ip: () => Promise<AsyncIterator<String>>;
  key: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface DeviceNullablePromise
  extends Promise<Device | null>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  ip: () => Promise<String>;
  key: () => Promise<String>;
  name: () => Promise<String>;
  status: () => Promise<String>;
}

export interface DeviceConnection {
  pageInfo: PageInfo;
  edges: DeviceEdge[];
}

export interface DeviceConnectionPromise
  extends Promise<DeviceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeviceEdge>>() => T;
  aggregate: <T = AggregateDevicePromise>() => T;
}

export interface DeviceConnectionSubscription
  extends Promise<AsyncIterator<DeviceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeviceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeviceSubscription>() => T;
}

export interface DeviceEdge {
  node: Device;
  cursor: String;
}

export interface DeviceEdgePromise extends Promise<DeviceEdge>, Fragmentable {
  node: <T = DevicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeviceEdgeSubscription
  extends Promise<AsyncIterator<DeviceEdge>>,
    Fragmentable {
  node: <T = DeviceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDevice {
  count: Int;
}

export interface AggregateDevicePromise
  extends Promise<AggregateDevice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeviceSubscription
  extends Promise<AsyncIterator<AggregateDevice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Mode {
  id: Int;
  name?: String;
}

export interface ModePromise extends Promise<Mode>, Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ModeSubscription
  extends Promise<AsyncIterator<Mode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ModeNullablePromise
  extends Promise<Mode | null>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ModeConnection {
  pageInfo: PageInfo;
  edges: ModeEdge[];
}

export interface ModeConnectionPromise
  extends Promise<ModeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ModeEdge>>() => T;
  aggregate: <T = AggregateModePromise>() => T;
}

export interface ModeConnectionSubscription
  extends Promise<AsyncIterator<ModeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ModeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateModeSubscription>() => T;
}

export interface ModeEdge {
  node: Mode;
  cursor: String;
}

export interface ModeEdgePromise extends Promise<ModeEdge>, Fragmentable {
  node: <T = ModePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ModeEdgeSubscription
  extends Promise<AsyncIterator<ModeEdge>>,
    Fragmentable {
  node: <T = ModeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMode {
  count: Int;
}

export interface AggregateModePromise
  extends Promise<AggregateMode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateModeSubscription
  extends Promise<AsyncIterator<AggregateMode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Room {
  id: Int;
  modeId?: Int;
  modeUpdated?: DateTimeOutput;
  name?: String;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<Int>;
  modeId: () => Promise<Int>;
  modeUpdated: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  modeUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<Int>;
  modeId: () => Promise<Int>;
  modeUpdated: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomsDevice {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
}

export interface RoomsDevicePromise extends Promise<RoomsDevice>, Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
}

export interface RoomsDeviceSubscription
  extends Promise<AsyncIterator<RoomsDevice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
}

export interface RoomsDeviceNullablePromise
  extends Promise<RoomsDevice | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
}

export interface RoomsDeviceConnection {
  pageInfo: PageInfo;
  edges: RoomsDeviceEdge[];
}

export interface RoomsDeviceConnectionPromise
  extends Promise<RoomsDeviceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomsDeviceEdge>>() => T;
  aggregate: <T = AggregateRoomsDevicePromise>() => T;
}

export interface RoomsDeviceConnectionSubscription
  extends Promise<AsyncIterator<RoomsDeviceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomsDeviceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomsDeviceSubscription>() => T;
}

export interface RoomsDeviceEdge {
  node: RoomsDevice;
  cursor: String;
}

export interface RoomsDeviceEdgePromise
  extends Promise<RoomsDeviceEdge>,
    Fragmentable {
  node: <T = RoomsDevicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomsDeviceEdgeSubscription
  extends Promise<AsyncIterator<RoomsDeviceEdge>>,
    Fragmentable {
  node: <T = RoomsDeviceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoomsDevice {
  count: Int;
}

export interface AggregateRoomsDevicePromise
  extends Promise<AggregateRoomsDevice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomsDeviceSubscription
  extends Promise<AsyncIterator<AggregateRoomsDevice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Scenario {
  id: Int;
  controllerDelay?: Int;
  controllerId?: Int;
  controllerValue?: Int;
  modeId?: Int;
  sensorEnd?: Float;
  sensorId?: Int;
  sensorStart?: Float;
  sortOrder?: Int;
}

export interface ScenarioPromise extends Promise<Scenario>, Fragmentable {
  id: () => Promise<Int>;
  controllerDelay: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  controllerValue: () => Promise<Int>;
  modeId: () => Promise<Int>;
  sensorEnd: () => Promise<Float>;
  sensorId: () => Promise<Int>;
  sensorStart: () => Promise<Float>;
  sortOrder: () => Promise<Int>;
}

export interface ScenarioSubscription
  extends Promise<AsyncIterator<Scenario>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controllerDelay: () => Promise<AsyncIterator<Int>>;
  controllerId: () => Promise<AsyncIterator<Int>>;
  controllerValue: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  sensorEnd: () => Promise<AsyncIterator<Float>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  sensorStart: () => Promise<AsyncIterator<Float>>;
  sortOrder: () => Promise<AsyncIterator<Int>>;
}

export interface ScenarioNullablePromise
  extends Promise<Scenario | null>,
    Fragmentable {
  id: () => Promise<Int>;
  controllerDelay: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  controllerValue: () => Promise<Int>;
  modeId: () => Promise<Int>;
  sensorEnd: () => Promise<Float>;
  sensorId: () => Promise<Int>;
  sensorStart: () => Promise<Float>;
  sortOrder: () => Promise<Int>;
}

export interface ScenarioConnection {
  pageInfo: PageInfo;
  edges: ScenarioEdge[];
}

export interface ScenarioConnectionPromise
  extends Promise<ScenarioConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScenarioEdge>>() => T;
  aggregate: <T = AggregateScenarioPromise>() => T;
}

export interface ScenarioConnectionSubscription
  extends Promise<AsyncIterator<ScenarioConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScenarioEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScenarioSubscription>() => T;
}

export interface ScenarioEdge {
  node: Scenario;
  cursor: String;
}

export interface ScenarioEdgePromise
  extends Promise<ScenarioEdge>,
    Fragmentable {
  node: <T = ScenarioPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScenarioEdgeSubscription
  extends Promise<AsyncIterator<ScenarioEdge>>,
    Fragmentable {
  node: <T = ScenarioSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScenario {
  count: Int;
}

export interface AggregateScenarioPromise
  extends Promise<AggregateScenario>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScenarioSubscription
  extends Promise<AsyncIterator<AggregateScenario>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Sensor {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
  sensorDelay?: Int;
  type?: String;
}

export interface SensorPromise extends Promise<Sensor>, Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorDelay: () => Promise<Int>;
  type: () => Promise<String>;
}

export interface SensorSubscription
  extends Promise<AsyncIterator<Sensor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorDelay: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface SensorNullablePromise
  extends Promise<Sensor | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorDelay: () => Promise<Int>;
  type: () => Promise<String>;
}

export interface SensorConnection {
  pageInfo: PageInfo;
  edges: SensorEdge[];
}

export interface SensorConnectionPromise
  extends Promise<SensorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SensorEdge>>() => T;
  aggregate: <T = AggregateSensorPromise>() => T;
}

export interface SensorConnectionSubscription
  extends Promise<AsyncIterator<SensorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SensorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSensorSubscription>() => T;
}

export interface SensorEdge {
  node: Sensor;
  cursor: String;
}

export interface SensorEdgePromise extends Promise<SensorEdge>, Fragmentable {
  node: <T = SensorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SensorEdgeSubscription
  extends Promise<AsyncIterator<SensorEdge>>,
    Fragmentable {
  node: <T = SensorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSensor {
  count: Int;
}

export interface AggregateSensorPromise
  extends Promise<AggregateSensor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSensorSubscription
  extends Promise<AsyncIterator<AggregateSensor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SensorsLog {
  id: Int;
  created?: DateTimeOutput;
  deviceId?: Int;
  roomId?: Int;
  sensorId?: Int;
  value?: String;
}

export interface SensorsLogPromise extends Promise<SensorsLog>, Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  value: () => Promise<String>;
}

export interface SensorsLogSubscription
  extends Promise<AsyncIterator<SensorsLog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface SensorsLogNullablePromise
  extends Promise<SensorsLog | null>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  value: () => Promise<String>;
}

export interface SensorsLogConnection {
  pageInfo: PageInfo;
  edges: SensorsLogEdge[];
}

export interface SensorsLogConnectionPromise
  extends Promise<SensorsLogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SensorsLogEdge>>() => T;
  aggregate: <T = AggregateSensorsLogPromise>() => T;
}

export interface SensorsLogConnectionSubscription
  extends Promise<AsyncIterator<SensorsLogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SensorsLogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSensorsLogSubscription>() => T;
}

export interface SensorsLogEdge {
  node: SensorsLog;
  cursor: String;
}

export interface SensorsLogEdgePromise
  extends Promise<SensorsLogEdge>,
    Fragmentable {
  node: <T = SensorsLogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SensorsLogEdgeSubscription
  extends Promise<AsyncIterator<SensorsLogEdge>>,
    Fragmentable {
  node: <T = SensorsLogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSensorsLog {
  count: Int;
}

export interface AggregateSensorsLogPromise
  extends Promise<AggregateSensorsLog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSensorsLogSubscription
  extends Promise<AsyncIterator<AggregateSensorsLog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SensorsState {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
  sensorId?: Int;
  updated?: DateTimeOutput;
  value?: String;
}

export interface SensorsStatePromise
  extends Promise<SensorsState>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface SensorsStateSubscription
  extends Promise<AsyncIterator<SensorsState>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface SensorsStateNullablePromise
  extends Promise<SensorsState | null>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface SensorsStateConnection {
  pageInfo: PageInfo;
  edges: SensorsStateEdge[];
}

export interface SensorsStateConnectionPromise
  extends Promise<SensorsStateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SensorsStateEdge>>() => T;
  aggregate: <T = AggregateSensorsStatePromise>() => T;
}

export interface SensorsStateConnectionSubscription
  extends Promise<AsyncIterator<SensorsStateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SensorsStateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSensorsStateSubscription>() => T;
}

export interface SensorsStateEdge {
  node: SensorsState;
  cursor: String;
}

export interface SensorsStateEdgePromise
  extends Promise<SensorsStateEdge>,
    Fragmentable {
  node: <T = SensorsStatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SensorsStateEdgeSubscription
  extends Promise<AsyncIterator<SensorsStateEdge>>,
    Fragmentable {
  node: <T = SensorsStateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSensorsState {
  count: Int;
}

export interface AggregateSensorsStatePromise
  extends Promise<AggregateSensorsState>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSensorsStateSubscription
  extends Promise<AsyncIterator<AggregateSensorsState>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ControllerSubscriptionPayload {
  mutation: MutationType;
  node: Controller;
  updatedFields: String[];
  previousValues: ControllerPreviousValues;
}

export interface ControllerSubscriptionPayloadPromise
  extends Promise<ControllerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ControllerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ControllerPreviousValuesPromise>() => T;
}

export interface ControllerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ControllerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ControllerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ControllerPreviousValuesSubscription>() => T;
}

export interface ControllerPreviousValues {
  id: Int;
  controller?: String;
  controllerDefault?: Float;
  deviceId?: Int;
  modeId: Int;
  name?: String;
}

export interface ControllerPreviousValuesPromise
  extends Promise<ControllerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  controller: () => Promise<String>;
  controllerDefault: () => Promise<Float>;
  deviceId: () => Promise<Int>;
  modeId: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ControllerPreviousValuesSubscription
  extends Promise<AsyncIterator<ControllerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controller: () => Promise<AsyncIterator<String>>;
  controllerDefault: () => Promise<AsyncIterator<Float>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ControllersStateSubscriptionPayload {
  mutation: MutationType;
  node: ControllersState;
  updatedFields: String[];
  previousValues: ControllersStatePreviousValues;
}

export interface ControllersStateSubscriptionPayloadPromise
  extends Promise<ControllersStateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ControllersStatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ControllersStatePreviousValuesPromise>() => T;
}

export interface ControllersStateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ControllersStateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ControllersStateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ControllersStatePreviousValuesSubscription>() => T;
}

export interface ControllersStatePreviousValues {
  id: Int;
  controllerId?: Int;
  deviceId?: Int;
  state?: String;
  updated?: DateTimeOutput;
}

export interface ControllersStatePreviousValuesPromise
  extends Promise<ControllersStatePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  state: () => Promise<String>;
  updated: () => Promise<DateTimeOutput>;
}

export interface ControllersStatePreviousValuesSubscription
  extends Promise<AsyncIterator<ControllersStatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controllerId: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<String>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DeviceSubscriptionPayload {
  mutation: MutationType;
  node: Device;
  updatedFields: String[];
  previousValues: DevicePreviousValues;
}

export interface DeviceSubscriptionPayloadPromise
  extends Promise<DeviceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DevicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DevicePreviousValuesPromise>() => T;
}

export interface DeviceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeviceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeviceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DevicePreviousValuesSubscription>() => T;
}

export interface DevicePreviousValues {
  id: Int;
  created?: DateTimeOutput;
  ip?: String;
  key?: String;
  name?: String;
  status?: String;
}

export interface DevicePreviousValuesPromise
  extends Promise<DevicePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  ip: () => Promise<String>;
  key: () => Promise<String>;
  name: () => Promise<String>;
  status: () => Promise<String>;
}

export interface DevicePreviousValuesSubscription
  extends Promise<AsyncIterator<DevicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  ip: () => Promise<AsyncIterator<String>>;
  key: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface ModeSubscriptionPayload {
  mutation: MutationType;
  node: Mode;
  updatedFields: String[];
  previousValues: ModePreviousValues;
}

export interface ModeSubscriptionPayloadPromise
  extends Promise<ModeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ModePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ModePreviousValuesPromise>() => T;
}

export interface ModeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ModeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ModeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ModePreviousValuesSubscription>() => T;
}

export interface ModePreviousValues {
  id: Int;
  name?: String;
}

export interface ModePreviousValuesPromise
  extends Promise<ModePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  name: () => Promise<String>;
}

export interface ModePreviousValuesSubscription
  extends Promise<AsyncIterator<ModePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: Int;
  modeId?: Int;
  modeUpdated?: DateTimeOutput;
  name?: String;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  modeId: () => Promise<Int>;
  modeUpdated: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  modeUpdated: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoomsDeviceSubscriptionPayload {
  mutation: MutationType;
  node: RoomsDevice;
  updatedFields: String[];
  previousValues: RoomsDevicePreviousValues;
}

export interface RoomsDeviceSubscriptionPayloadPromise
  extends Promise<RoomsDeviceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomsDevicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomsDevicePreviousValuesPromise>() => T;
}

export interface RoomsDeviceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomsDeviceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomsDeviceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomsDevicePreviousValuesSubscription>() => T;
}

export interface RoomsDevicePreviousValues {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
}

export interface RoomsDevicePreviousValuesPromise
  extends Promise<RoomsDevicePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
}

export interface RoomsDevicePreviousValuesSubscription
  extends Promise<AsyncIterator<RoomsDevicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
}

export interface ScenarioSubscriptionPayload {
  mutation: MutationType;
  node: Scenario;
  updatedFields: String[];
  previousValues: ScenarioPreviousValues;
}

export interface ScenarioSubscriptionPayloadPromise
  extends Promise<ScenarioSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScenarioPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScenarioPreviousValuesPromise>() => T;
}

export interface ScenarioSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScenarioSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScenarioSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScenarioPreviousValuesSubscription>() => T;
}

export interface ScenarioPreviousValues {
  id: Int;
  controllerDelay?: Int;
  controllerId?: Int;
  controllerValue?: Int;
  modeId?: Int;
  sensorEnd?: Float;
  sensorId?: Int;
  sensorStart?: Float;
  sortOrder?: Int;
}

export interface ScenarioPreviousValuesPromise
  extends Promise<ScenarioPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  controllerDelay: () => Promise<Int>;
  controllerId: () => Promise<Int>;
  controllerValue: () => Promise<Int>;
  modeId: () => Promise<Int>;
  sensorEnd: () => Promise<Float>;
  sensorId: () => Promise<Int>;
  sensorStart: () => Promise<Float>;
  sortOrder: () => Promise<Int>;
}

export interface ScenarioPreviousValuesSubscription
  extends Promise<AsyncIterator<ScenarioPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  controllerDelay: () => Promise<AsyncIterator<Int>>;
  controllerId: () => Promise<AsyncIterator<Int>>;
  controllerValue: () => Promise<AsyncIterator<Int>>;
  modeId: () => Promise<AsyncIterator<Int>>;
  sensorEnd: () => Promise<AsyncIterator<Float>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  sensorStart: () => Promise<AsyncIterator<Float>>;
  sortOrder: () => Promise<AsyncIterator<Int>>;
}

export interface SensorSubscriptionPayload {
  mutation: MutationType;
  node: Sensor;
  updatedFields: String[];
  previousValues: SensorPreviousValues;
}

export interface SensorSubscriptionPayloadPromise
  extends Promise<SensorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SensorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SensorPreviousValuesPromise>() => T;
}

export interface SensorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SensorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SensorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SensorPreviousValuesSubscription>() => T;
}

export interface SensorPreviousValues {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
  sensorDelay?: Int;
  type?: String;
}

export interface SensorPreviousValuesPromise
  extends Promise<SensorPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorDelay: () => Promise<Int>;
  type: () => Promise<String>;
}

export interface SensorPreviousValuesSubscription
  extends Promise<AsyncIterator<SensorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorDelay: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface SensorsLogSubscriptionPayload {
  mutation: MutationType;
  node: SensorsLog;
  updatedFields: String[];
  previousValues: SensorsLogPreviousValues;
}

export interface SensorsLogSubscriptionPayloadPromise
  extends Promise<SensorsLogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SensorsLogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SensorsLogPreviousValuesPromise>() => T;
}

export interface SensorsLogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SensorsLogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SensorsLogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SensorsLogPreviousValuesSubscription>() => T;
}

export interface SensorsLogPreviousValues {
  id: Int;
  created?: DateTimeOutput;
  deviceId?: Int;
  roomId?: Int;
  sensorId?: Int;
  value?: String;
}

export interface SensorsLogPreviousValuesPromise
  extends Promise<SensorsLogPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  created: () => Promise<DateTimeOutput>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  value: () => Promise<String>;
}

export interface SensorsLogPreviousValuesSubscription
  extends Promise<AsyncIterator<SensorsLogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  created: () => Promise<AsyncIterator<DateTimeOutput>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  value: () => Promise<AsyncIterator<String>>;
}

export interface SensorsStateSubscriptionPayload {
  mutation: MutationType;
  node: SensorsState;
  updatedFields: String[];
  previousValues: SensorsStatePreviousValues;
}

export interface SensorsStateSubscriptionPayloadPromise
  extends Promise<SensorsStateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SensorsStatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SensorsStatePreviousValuesPromise>() => T;
}

export interface SensorsStateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SensorsStateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SensorsStateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SensorsStatePreviousValuesSubscription>() => T;
}

export interface SensorsStatePreviousValues {
  id: Int;
  deviceId?: Int;
  roomId?: Int;
  sensorId?: Int;
  updated?: DateTimeOutput;
  value?: String;
}

export interface SensorsStatePreviousValuesPromise
  extends Promise<SensorsStatePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  deviceId: () => Promise<Int>;
  roomId: () => Promise<Int>;
  sensorId: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
  value: () => Promise<String>;
}

export interface SensorsStatePreviousValuesSubscription
  extends Promise<AsyncIterator<SensorsStatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  deviceId: () => Promise<AsyncIterator<Int>>;
  roomId: () => Promise<AsyncIterator<Int>>;
  sensorId: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
  value: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Controller",
    embedded: false
  },
  {
    name: "ControllersState",
    embedded: false
  },
  {
    name: "Device",
    embedded: false
  },
  {
    name: "Mode",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "RoomsDevice",
    embedded: false
  },
  {
    name: "Scenario",
    embedded: false
  },
  {
    name: "Sensor",
    embedded: false
  },
  {
    name: "SensorsLog",
    embedded: false
  },
  {
    name: "SensorsState",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
