// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateController {
  count: Int!
}

type AggregateControllersState {
  count: Int!
}

type AggregateDevice {
  count: Int!
}

type AggregateMode {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateRoomsDevice {
  count: Int!
}

type AggregateScenario {
  count: Int!
}

type AggregateSensor {
  count: Int!
}

type AggregateSensorsLog {
  count: Int!
}

type AggregateSensorsState {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Controller {
  id: Int!
  controller: String
  controllerDefault: Float
  deviceId: Int
  modeId: Int!
  name: String
}

type ControllerConnection {
  pageInfo: PageInfo!
  edges: [ControllerEdge]!
  aggregate: AggregateController!
}

input ControllerCreateInput {
  id: Int
  controller: String
  controllerDefault: Float
  deviceId: Int
  modeId: Int
  name: String
}

type ControllerEdge {
  node: Controller!
  cursor: String!
}

enum ControllerOrderByInput {
  id_ASC
  id_DESC
  controller_ASC
  controller_DESC
  controllerDefault_ASC
  controllerDefault_DESC
  deviceId_ASC
  deviceId_DESC
  modeId_ASC
  modeId_DESC
  name_ASC
  name_DESC
}

type ControllerPreviousValues {
  id: Int!
  controller: String
  controllerDefault: Float
  deviceId: Int
  modeId: Int!
  name: String
}

type ControllersState {
  id: Int!
  controllerId: Int
  deviceId: Int
  state: String
  updated: DateTime
}

type ControllersStateConnection {
  pageInfo: PageInfo!
  edges: [ControllersStateEdge]!
  aggregate: AggregateControllersState!
}

input ControllersStateCreateInput {
  id: Int
  controllerId: Int
  deviceId: Int
  state: String
  updated: DateTime
}

type ControllersStateEdge {
  node: ControllersState!
  cursor: String!
}

enum ControllersStateOrderByInput {
  id_ASC
  id_DESC
  controllerId_ASC
  controllerId_DESC
  deviceId_ASC
  deviceId_DESC
  state_ASC
  state_DESC
  updated_ASC
  updated_DESC
}

type ControllersStatePreviousValues {
  id: Int!
  controllerId: Int
  deviceId: Int
  state: String
  updated: DateTime
}

type ControllersStateSubscriptionPayload {
  mutation: MutationType!
  node: ControllersState
  updatedFields: [String!]
  previousValues: ControllersStatePreviousValues
}

input ControllersStateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ControllersStateWhereInput
  AND: [ControllersStateSubscriptionWhereInput!]
  OR: [ControllersStateSubscriptionWhereInput!]
  NOT: [ControllersStateSubscriptionWhereInput!]
}

input ControllersStateUpdateInput {
  controllerId: Int
  deviceId: Int
  state: String
  updated: DateTime
}

input ControllersStateUpdateManyMutationInput {
  controllerId: Int
  deviceId: Int
  state: String
  updated: DateTime
}

input ControllersStateWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  controllerId: Int
  controllerId_not: Int
  controllerId_in: [Int!]
  controllerId_not_in: [Int!]
  controllerId_lt: Int
  controllerId_lte: Int
  controllerId_gt: Int
  controllerId_gte: Int
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [ControllersStateWhereInput!]
  OR: [ControllersStateWhereInput!]
  NOT: [ControllersStateWhereInput!]
}

input ControllersStateWhereUniqueInput {
  id: Int
}

type ControllerSubscriptionPayload {
  mutation: MutationType!
  node: Controller
  updatedFields: [String!]
  previousValues: ControllerPreviousValues
}

input ControllerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ControllerWhereInput
  AND: [ControllerSubscriptionWhereInput!]
  OR: [ControllerSubscriptionWhereInput!]
  NOT: [ControllerSubscriptionWhereInput!]
}

input ControllerUpdateInput {
  controller: String
  controllerDefault: Float
  deviceId: Int
  modeId: Int
  name: String
}

input ControllerUpdateManyMutationInput {
  controller: String
  controllerDefault: Float
  deviceId: Int
  modeId: Int
  name: String
}

input ControllerWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  controller: String
  controller_not: String
  controller_in: [String!]
  controller_not_in: [String!]
  controller_lt: String
  controller_lte: String
  controller_gt: String
  controller_gte: String
  controller_contains: String
  controller_not_contains: String
  controller_starts_with: String
  controller_not_starts_with: String
  controller_ends_with: String
  controller_not_ends_with: String
  controllerDefault: Float
  controllerDefault_not: Float
  controllerDefault_in: [Float!]
  controllerDefault_not_in: [Float!]
  controllerDefault_lt: Float
  controllerDefault_lte: Float
  controllerDefault_gt: Float
  controllerDefault_gte: Float
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  modeId: Int
  modeId_not: Int
  modeId_in: [Int!]
  modeId_not_in: [Int!]
  modeId_lt: Int
  modeId_lte: Int
  modeId_gt: Int
  modeId_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ControllerWhereInput!]
  OR: [ControllerWhereInput!]
  NOT: [ControllerWhereInput!]
}

input ControllerWhereUniqueInput {
  id: Int
}

scalar DateTime

type Device {
  id: Int!
  created: DateTime
  ip: String
  key: String
  name: String
  status: String
}

type DeviceConnection {
  pageInfo: PageInfo!
  edges: [DeviceEdge]!
  aggregate: AggregateDevice!
}

input DeviceCreateInput {
  id: Int
  created: DateTime
  ip: String
  key: String
  name: String
  status: String
}

type DeviceEdge {
  node: Device!
  cursor: String!
}

enum DeviceOrderByInput {
  id_ASC
  id_DESC
  created_ASC
  created_DESC
  ip_ASC
  ip_DESC
  key_ASC
  key_DESC
  name_ASC
  name_DESC
  status_ASC
  status_DESC
}

type DevicePreviousValues {
  id: Int!
  created: DateTime
  ip: String
  key: String
  name: String
  status: String
}

type DeviceSubscriptionPayload {
  mutation: MutationType!
  node: Device
  updatedFields: [String!]
  previousValues: DevicePreviousValues
}

input DeviceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DeviceWhereInput
  AND: [DeviceSubscriptionWhereInput!]
  OR: [DeviceSubscriptionWhereInput!]
  NOT: [DeviceSubscriptionWhereInput!]
}

input DeviceUpdateInput {
  created: DateTime
  ip: String
  key: String
  name: String
  status: String
}

input DeviceUpdateManyMutationInput {
  created: DateTime
  ip: String
  key: String
  name: String
  status: String
}

input DeviceWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  status: String
  status_not: String
  status_in: [String!]
  status_not_in: [String!]
  status_lt: String
  status_lte: String
  status_gt: String
  status_gte: String
  status_contains: String
  status_not_contains: String
  status_starts_with: String
  status_not_starts_with: String
  status_ends_with: String
  status_not_ends_with: String
  AND: [DeviceWhereInput!]
  OR: [DeviceWhereInput!]
  NOT: [DeviceWhereInput!]
}

input DeviceWhereUniqueInput {
  id: Int
}

scalar Long

type Mode {
  id: Int!
  name: String
}

type ModeConnection {
  pageInfo: PageInfo!
  edges: [ModeEdge]!
  aggregate: AggregateMode!
}

input ModeCreateInput {
  id: Int
  name: String
}

type ModeEdge {
  node: Mode!
  cursor: String!
}

enum ModeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ModePreviousValues {
  id: Int!
  name: String
}

type ModeSubscriptionPayload {
  mutation: MutationType!
  node: Mode
  updatedFields: [String!]
  previousValues: ModePreviousValues
}

input ModeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ModeWhereInput
  AND: [ModeSubscriptionWhereInput!]
  OR: [ModeSubscriptionWhereInput!]
  NOT: [ModeSubscriptionWhereInput!]
}

input ModeUpdateInput {
  name: String
}

input ModeUpdateManyMutationInput {
  name: String
}

input ModeWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ModeWhereInput!]
  OR: [ModeWhereInput!]
  NOT: [ModeWhereInput!]
}

input ModeWhereUniqueInput {
  id: Int
}

type Mutation {
  createController(data: ControllerCreateInput!): Controller!
  updateController(data: ControllerUpdateInput!, where: ControllerWhereUniqueInput!): Controller
  updateManyControllers(data: ControllerUpdateManyMutationInput!, where: ControllerWhereInput): BatchPayload!
  upsertController(where: ControllerWhereUniqueInput!, create: ControllerCreateInput!, update: ControllerUpdateInput!): Controller!
  deleteController(where: ControllerWhereUniqueInput!): Controller
  deleteManyControllers(where: ControllerWhereInput): BatchPayload!
  createControllersState(data: ControllersStateCreateInput!): ControllersState!
  updateControllersState(data: ControllersStateUpdateInput!, where: ControllersStateWhereUniqueInput!): ControllersState
  updateManyControllersStates(data: ControllersStateUpdateManyMutationInput!, where: ControllersStateWhereInput): BatchPayload!
  upsertControllersState(where: ControllersStateWhereUniqueInput!, create: ControllersStateCreateInput!, update: ControllersStateUpdateInput!): ControllersState!
  deleteControllersState(where: ControllersStateWhereUniqueInput!): ControllersState
  deleteManyControllersStates(where: ControllersStateWhereInput): BatchPayload!
  createDevice(data: DeviceCreateInput!): Device!
  updateDevice(data: DeviceUpdateInput!, where: DeviceWhereUniqueInput!): Device
  updateManyDevices(data: DeviceUpdateManyMutationInput!, where: DeviceWhereInput): BatchPayload!
  upsertDevice(where: DeviceWhereUniqueInput!, create: DeviceCreateInput!, update: DeviceUpdateInput!): Device!
  deleteDevice(where: DeviceWhereUniqueInput!): Device
  deleteManyDevices(where: DeviceWhereInput): BatchPayload!
  createMode(data: ModeCreateInput!): Mode!
  updateMode(data: ModeUpdateInput!, where: ModeWhereUniqueInput!): Mode
  updateManyModes(data: ModeUpdateManyMutationInput!, where: ModeWhereInput): BatchPayload!
  upsertMode(where: ModeWhereUniqueInput!, create: ModeCreateInput!, update: ModeUpdateInput!): Mode!
  deleteMode(where: ModeWhereUniqueInput!): Mode
  deleteManyModes(where: ModeWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createRoomsDevice(data: RoomsDeviceCreateInput!): RoomsDevice!
  updateRoomsDevice(data: RoomsDeviceUpdateInput!, where: RoomsDeviceWhereUniqueInput!): RoomsDevice
  updateManyRoomsDevices(data: RoomsDeviceUpdateManyMutationInput!, where: RoomsDeviceWhereInput): BatchPayload!
  upsertRoomsDevice(where: RoomsDeviceWhereUniqueInput!, create: RoomsDeviceCreateInput!, update: RoomsDeviceUpdateInput!): RoomsDevice!
  deleteRoomsDevice(where: RoomsDeviceWhereUniqueInput!): RoomsDevice
  deleteManyRoomsDevices(where: RoomsDeviceWhereInput): BatchPayload!
  createScenario(data: ScenarioCreateInput!): Scenario!
  updateScenario(data: ScenarioUpdateInput!, where: ScenarioWhereUniqueInput!): Scenario
  updateManyScenarios(data: ScenarioUpdateManyMutationInput!, where: ScenarioWhereInput): BatchPayload!
  upsertScenario(where: ScenarioWhereUniqueInput!, create: ScenarioCreateInput!, update: ScenarioUpdateInput!): Scenario!
  deleteScenario(where: ScenarioWhereUniqueInput!): Scenario
  deleteManyScenarios(where: ScenarioWhereInput): BatchPayload!
  createSensor(data: SensorCreateInput!): Sensor!
  updateSensor(data: SensorUpdateInput!, where: SensorWhereUniqueInput!): Sensor
  updateManySensors(data: SensorUpdateManyMutationInput!, where: SensorWhereInput): BatchPayload!
  upsertSensor(where: SensorWhereUniqueInput!, create: SensorCreateInput!, update: SensorUpdateInput!): Sensor!
  deleteSensor(where: SensorWhereUniqueInput!): Sensor
  deleteManySensors(where: SensorWhereInput): BatchPayload!
  createSensorsLog(data: SensorsLogCreateInput!): SensorsLog!
  updateSensorsLog(data: SensorsLogUpdateInput!, where: SensorsLogWhereUniqueInput!): SensorsLog
  updateManySensorsLogs(data: SensorsLogUpdateManyMutationInput!, where: SensorsLogWhereInput): BatchPayload!
  upsertSensorsLog(where: SensorsLogWhereUniqueInput!, create: SensorsLogCreateInput!, update: SensorsLogUpdateInput!): SensorsLog!
  deleteSensorsLog(where: SensorsLogWhereUniqueInput!): SensorsLog
  deleteManySensorsLogs(where: SensorsLogWhereInput): BatchPayload!
  createSensorsState(data: SensorsStateCreateInput!): SensorsState!
  updateSensorsState(data: SensorsStateUpdateInput!, where: SensorsStateWhereUniqueInput!): SensorsState
  updateManySensorsStates(data: SensorsStateUpdateManyMutationInput!, where: SensorsStateWhereInput): BatchPayload!
  upsertSensorsState(where: SensorsStateWhereUniqueInput!, create: SensorsStateCreateInput!, update: SensorsStateUpdateInput!): SensorsState!
  deleteSensorsState(where: SensorsStateWhereUniqueInput!): SensorsState
  deleteManySensorsStates(where: SensorsStateWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  controller(where: ControllerWhereUniqueInput!): Controller
  controllers(where: ControllerWhereInput, orderBy: ControllerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Controller]!
  controllersConnection(where: ControllerWhereInput, orderBy: ControllerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ControllerConnection!
  controllersState(where: ControllersStateWhereUniqueInput!): ControllersState
  controllersStates(where: ControllersStateWhereInput, orderBy: ControllersStateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ControllersState]!
  controllersStatesConnection(where: ControllersStateWhereInput, orderBy: ControllersStateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ControllersStateConnection!
  device(where: DeviceWhereUniqueInput!): Device
  devices(where: DeviceWhereInput, orderBy: DeviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Device]!
  devicesConnection(where: DeviceWhereInput, orderBy: DeviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DeviceConnection!
  mode(where: ModeWhereUniqueInput!): Mode
  modes(where: ModeWhereInput, orderBy: ModeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mode]!
  modesConnection(where: ModeWhereInput, orderBy: ModeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ModeConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  roomsDevice(where: RoomsDeviceWhereUniqueInput!): RoomsDevice
  roomsDevices(where: RoomsDeviceWhereInput, orderBy: RoomsDeviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RoomsDevice]!
  roomsDevicesConnection(where: RoomsDeviceWhereInput, orderBy: RoomsDeviceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomsDeviceConnection!
  scenario(where: ScenarioWhereUniqueInput!): Scenario
  scenarios(where: ScenarioWhereInput, orderBy: ScenarioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Scenario]!
  scenariosConnection(where: ScenarioWhereInput, orderBy: ScenarioOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScenarioConnection!
  sensor(where: SensorWhereUniqueInput!): Sensor
  sensors(where: SensorWhereInput, orderBy: SensorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sensor]!
  sensorsConnection(where: SensorWhereInput, orderBy: SensorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SensorConnection!
  sensorsLog(where: SensorsLogWhereUniqueInput!): SensorsLog
  sensorsLogs(where: SensorsLogWhereInput, orderBy: SensorsLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SensorsLog]!
  sensorsLogsConnection(where: SensorsLogWhereInput, orderBy: SensorsLogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SensorsLogConnection!
  sensorsState(where: SensorsStateWhereUniqueInput!): SensorsState
  sensorsStates(where: SensorsStateWhereInput, orderBy: SensorsStateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SensorsState]!
  sensorsStatesConnection(where: SensorsStateWhereInput, orderBy: SensorsStateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SensorsStateConnection!
  node(id: ID!): Node
}

type Room {
  id: Int!
  modeId: Int
  modeUpdated: DateTime
  name: String
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: Int
  modeId: Int
  modeUpdated: DateTime
  name: String
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  modeId_ASC
  modeId_DESC
  modeUpdated_ASC
  modeUpdated_DESC
  name_ASC
  name_DESC
}

type RoomPreviousValues {
  id: Int!
  modeId: Int
  modeUpdated: DateTime
  name: String
}

type RoomsDevice {
  id: Int!
  deviceId: Int
  roomId: Int
}

type RoomsDeviceConnection {
  pageInfo: PageInfo!
  edges: [RoomsDeviceEdge]!
  aggregate: AggregateRoomsDevice!
}

input RoomsDeviceCreateInput {
  id: Int
  deviceId: Int
  roomId: Int
}

type RoomsDeviceEdge {
  node: RoomsDevice!
  cursor: String!
}

enum RoomsDeviceOrderByInput {
  id_ASC
  id_DESC
  deviceId_ASC
  deviceId_DESC
  roomId_ASC
  roomId_DESC
}

type RoomsDevicePreviousValues {
  id: Int!
  deviceId: Int
  roomId: Int
}

type RoomsDeviceSubscriptionPayload {
  mutation: MutationType!
  node: RoomsDevice
  updatedFields: [String!]
  previousValues: RoomsDevicePreviousValues
}

input RoomsDeviceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomsDeviceWhereInput
  AND: [RoomsDeviceSubscriptionWhereInput!]
  OR: [RoomsDeviceSubscriptionWhereInput!]
  NOT: [RoomsDeviceSubscriptionWhereInput!]
}

input RoomsDeviceUpdateInput {
  deviceId: Int
  roomId: Int
}

input RoomsDeviceUpdateManyMutationInput {
  deviceId: Int
  roomId: Int
}

input RoomsDeviceWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  roomId: Int
  roomId_not: Int
  roomId_in: [Int!]
  roomId_not_in: [Int!]
  roomId_lt: Int
  roomId_lte: Int
  roomId_gt: Int
  roomId_gte: Int
  AND: [RoomsDeviceWhereInput!]
  OR: [RoomsDeviceWhereInput!]
  NOT: [RoomsDeviceWhereInput!]
}

input RoomsDeviceWhereUniqueInput {
  id: Int
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

input RoomUpdateInput {
  modeId: Int
  modeUpdated: DateTime
  name: String
}

input RoomUpdateManyMutationInput {
  modeId: Int
  modeUpdated: DateTime
  name: String
}

input RoomWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  modeId: Int
  modeId_not: Int
  modeId_in: [Int!]
  modeId_not_in: [Int!]
  modeId_lt: Int
  modeId_lte: Int
  modeId_gt: Int
  modeId_gte: Int
  modeUpdated: DateTime
  modeUpdated_not: DateTime
  modeUpdated_in: [DateTime!]
  modeUpdated_not_in: [DateTime!]
  modeUpdated_lt: DateTime
  modeUpdated_lte: DateTime
  modeUpdated_gt: DateTime
  modeUpdated_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: Int
}

type Scenario {
  id: Int!
  controllerDelay: Int
  controllerId: Int
  controllerValue: Int
  modeId: Int
  sensorEnd: Float
  sensorId: Int
  sensorStart: Float
  sortOrder: Int
}

type ScenarioConnection {
  pageInfo: PageInfo!
  edges: [ScenarioEdge]!
  aggregate: AggregateScenario!
}

input ScenarioCreateInput {
  id: Int
  controllerDelay: Int
  controllerId: Int
  controllerValue: Int
  modeId: Int
  sensorEnd: Float
  sensorId: Int
  sensorStart: Float
  sortOrder: Int
}

type ScenarioEdge {
  node: Scenario!
  cursor: String!
}

enum ScenarioOrderByInput {
  id_ASC
  id_DESC
  controllerDelay_ASC
  controllerDelay_DESC
  controllerId_ASC
  controllerId_DESC
  controllerValue_ASC
  controllerValue_DESC
  modeId_ASC
  modeId_DESC
  sensorEnd_ASC
  sensorEnd_DESC
  sensorId_ASC
  sensorId_DESC
  sensorStart_ASC
  sensorStart_DESC
  sortOrder_ASC
  sortOrder_DESC
}

type ScenarioPreviousValues {
  id: Int!
  controllerDelay: Int
  controllerId: Int
  controllerValue: Int
  modeId: Int
  sensorEnd: Float
  sensorId: Int
  sensorStart: Float
  sortOrder: Int
}

type ScenarioSubscriptionPayload {
  mutation: MutationType!
  node: Scenario
  updatedFields: [String!]
  previousValues: ScenarioPreviousValues
}

input ScenarioSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScenarioWhereInput
  AND: [ScenarioSubscriptionWhereInput!]
  OR: [ScenarioSubscriptionWhereInput!]
  NOT: [ScenarioSubscriptionWhereInput!]
}

input ScenarioUpdateInput {
  controllerDelay: Int
  controllerId: Int
  controllerValue: Int
  modeId: Int
  sensorEnd: Float
  sensorId: Int
  sensorStart: Float
  sortOrder: Int
}

input ScenarioUpdateManyMutationInput {
  controllerDelay: Int
  controllerId: Int
  controllerValue: Int
  modeId: Int
  sensorEnd: Float
  sensorId: Int
  sensorStart: Float
  sortOrder: Int
}

input ScenarioWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  controllerDelay: Int
  controllerDelay_not: Int
  controllerDelay_in: [Int!]
  controllerDelay_not_in: [Int!]
  controllerDelay_lt: Int
  controllerDelay_lte: Int
  controllerDelay_gt: Int
  controllerDelay_gte: Int
  controllerId: Int
  controllerId_not: Int
  controllerId_in: [Int!]
  controllerId_not_in: [Int!]
  controllerId_lt: Int
  controllerId_lte: Int
  controllerId_gt: Int
  controllerId_gte: Int
  controllerValue: Int
  controllerValue_not: Int
  controllerValue_in: [Int!]
  controllerValue_not_in: [Int!]
  controllerValue_lt: Int
  controllerValue_lte: Int
  controllerValue_gt: Int
  controllerValue_gte: Int
  modeId: Int
  modeId_not: Int
  modeId_in: [Int!]
  modeId_not_in: [Int!]
  modeId_lt: Int
  modeId_lte: Int
  modeId_gt: Int
  modeId_gte: Int
  sensorEnd: Float
  sensorEnd_not: Float
  sensorEnd_in: [Float!]
  sensorEnd_not_in: [Float!]
  sensorEnd_lt: Float
  sensorEnd_lte: Float
  sensorEnd_gt: Float
  sensorEnd_gte: Float
  sensorId: Int
  sensorId_not: Int
  sensorId_in: [Int!]
  sensorId_not_in: [Int!]
  sensorId_lt: Int
  sensorId_lte: Int
  sensorId_gt: Int
  sensorId_gte: Int
  sensorStart: Float
  sensorStart_not: Float
  sensorStart_in: [Float!]
  sensorStart_not_in: [Float!]
  sensorStart_lt: Float
  sensorStart_lte: Float
  sensorStart_gt: Float
  sensorStart_gte: Float
  sortOrder: Int
  sortOrder_not: Int
  sortOrder_in: [Int!]
  sortOrder_not_in: [Int!]
  sortOrder_lt: Int
  sortOrder_lte: Int
  sortOrder_gt: Int
  sortOrder_gte: Int
  AND: [ScenarioWhereInput!]
  OR: [ScenarioWhereInput!]
  NOT: [ScenarioWhereInput!]
}

input ScenarioWhereUniqueInput {
  id: Int
}

type Sensor {
  id: Int!
  deviceId: Int
  roomId: Int
  sensorDelay: Int
  type: String
}

type SensorConnection {
  pageInfo: PageInfo!
  edges: [SensorEdge]!
  aggregate: AggregateSensor!
}

input SensorCreateInput {
  id: Int
  deviceId: Int
  roomId: Int
  sensorDelay: Int
  type: String
}

type SensorEdge {
  node: Sensor!
  cursor: String!
}

enum SensorOrderByInput {
  id_ASC
  id_DESC
  deviceId_ASC
  deviceId_DESC
  roomId_ASC
  roomId_DESC
  sensorDelay_ASC
  sensorDelay_DESC
  type_ASC
  type_DESC
}

type SensorPreviousValues {
  id: Int!
  deviceId: Int
  roomId: Int
  sensorDelay: Int
  type: String
}

type SensorsLog {
  id: Int!
  created: DateTime
  deviceId: Int
  roomId: Int
  sensorId: Int
  value: String
}

type SensorsLogConnection {
  pageInfo: PageInfo!
  edges: [SensorsLogEdge]!
  aggregate: AggregateSensorsLog!
}

input SensorsLogCreateInput {
  id: Int
  created: DateTime
  deviceId: Int
  roomId: Int
  sensorId: Int
  value: String
}

type SensorsLogEdge {
  node: SensorsLog!
  cursor: String!
}

enum SensorsLogOrderByInput {
  id_ASC
  id_DESC
  created_ASC
  created_DESC
  deviceId_ASC
  deviceId_DESC
  roomId_ASC
  roomId_DESC
  sensorId_ASC
  sensorId_DESC
  value_ASC
  value_DESC
}

type SensorsLogPreviousValues {
  id: Int!
  created: DateTime
  deviceId: Int
  roomId: Int
  sensorId: Int
  value: String
}

type SensorsLogSubscriptionPayload {
  mutation: MutationType!
  node: SensorsLog
  updatedFields: [String!]
  previousValues: SensorsLogPreviousValues
}

input SensorsLogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SensorsLogWhereInput
  AND: [SensorsLogSubscriptionWhereInput!]
  OR: [SensorsLogSubscriptionWhereInput!]
  NOT: [SensorsLogSubscriptionWhereInput!]
}

input SensorsLogUpdateInput {
  created: DateTime
  deviceId: Int
  roomId: Int
  sensorId: Int
  value: String
}

input SensorsLogUpdateManyMutationInput {
  created: DateTime
  deviceId: Int
  roomId: Int
  sensorId: Int
  value: String
}

input SensorsLogWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  created: DateTime
  created_not: DateTime
  created_in: [DateTime!]
  created_not_in: [DateTime!]
  created_lt: DateTime
  created_lte: DateTime
  created_gt: DateTime
  created_gte: DateTime
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  roomId: Int
  roomId_not: Int
  roomId_in: [Int!]
  roomId_not_in: [Int!]
  roomId_lt: Int
  roomId_lte: Int
  roomId_gt: Int
  roomId_gte: Int
  sensorId: Int
  sensorId_not: Int
  sensorId_in: [Int!]
  sensorId_not_in: [Int!]
  sensorId_lt: Int
  sensorId_lte: Int
  sensorId_gt: Int
  sensorId_gte: Int
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [SensorsLogWhereInput!]
  OR: [SensorsLogWhereInput!]
  NOT: [SensorsLogWhereInput!]
}

input SensorsLogWhereUniqueInput {
  id: Int
}

type SensorsState {
  id: Int!
  deviceId: Int
  roomId: Int
  sensorId: Int
  updated: DateTime
  value: String
}

type SensorsStateConnection {
  pageInfo: PageInfo!
  edges: [SensorsStateEdge]!
  aggregate: AggregateSensorsState!
}

input SensorsStateCreateInput {
  id: Int
  deviceId: Int
  roomId: Int
  sensorId: Int
  updated: DateTime
  value: String
}

type SensorsStateEdge {
  node: SensorsState!
  cursor: String!
}

enum SensorsStateOrderByInput {
  id_ASC
  id_DESC
  deviceId_ASC
  deviceId_DESC
  roomId_ASC
  roomId_DESC
  sensorId_ASC
  sensorId_DESC
  updated_ASC
  updated_DESC
  value_ASC
  value_DESC
}

type SensorsStatePreviousValues {
  id: Int!
  deviceId: Int
  roomId: Int
  sensorId: Int
  updated: DateTime
  value: String
}

type SensorsStateSubscriptionPayload {
  mutation: MutationType!
  node: SensorsState
  updatedFields: [String!]
  previousValues: SensorsStatePreviousValues
}

input SensorsStateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SensorsStateWhereInput
  AND: [SensorsStateSubscriptionWhereInput!]
  OR: [SensorsStateSubscriptionWhereInput!]
  NOT: [SensorsStateSubscriptionWhereInput!]
}

input SensorsStateUpdateInput {
  deviceId: Int
  roomId: Int
  sensorId: Int
  updated: DateTime
  value: String
}

input SensorsStateUpdateManyMutationInput {
  deviceId: Int
  roomId: Int
  sensorId: Int
  updated: DateTime
  value: String
}

input SensorsStateWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  roomId: Int
  roomId_not: Int
  roomId_in: [Int!]
  roomId_not_in: [Int!]
  roomId_lt: Int
  roomId_lte: Int
  roomId_gt: Int
  roomId_gte: Int
  sensorId: Int
  sensorId_not: Int
  sensorId_in: [Int!]
  sensorId_not_in: [Int!]
  sensorId_lt: Int
  sensorId_lte: Int
  sensorId_gt: Int
  sensorId_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  AND: [SensorsStateWhereInput!]
  OR: [SensorsStateWhereInput!]
  NOT: [SensorsStateWhereInput!]
}

input SensorsStateWhereUniqueInput {
  id: Int
}

type SensorSubscriptionPayload {
  mutation: MutationType!
  node: Sensor
  updatedFields: [String!]
  previousValues: SensorPreviousValues
}

input SensorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SensorWhereInput
  AND: [SensorSubscriptionWhereInput!]
  OR: [SensorSubscriptionWhereInput!]
  NOT: [SensorSubscriptionWhereInput!]
}

input SensorUpdateInput {
  deviceId: Int
  roomId: Int
  sensorDelay: Int
  type: String
}

input SensorUpdateManyMutationInput {
  deviceId: Int
  roomId: Int
  sensorDelay: Int
  type: String
}

input SensorWhereInput {
  id: Int
  id_not: Int
  id_in: [Int!]
  id_not_in: [Int!]
  id_lt: Int
  id_lte: Int
  id_gt: Int
  id_gte: Int
  deviceId: Int
  deviceId_not: Int
  deviceId_in: [Int!]
  deviceId_not_in: [Int!]
  deviceId_lt: Int
  deviceId_lte: Int
  deviceId_gt: Int
  deviceId_gte: Int
  roomId: Int
  roomId_not: Int
  roomId_in: [Int!]
  roomId_not_in: [Int!]
  roomId_lt: Int
  roomId_lte: Int
  roomId_gt: Int
  roomId_gte: Int
  sensorDelay: Int
  sensorDelay_not: Int
  sensorDelay_in: [Int!]
  sensorDelay_not_in: [Int!]
  sensorDelay_lt: Int
  sensorDelay_lte: Int
  sensorDelay_gt: Int
  sensorDelay_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  AND: [SensorWhereInput!]
  OR: [SensorWhereInput!]
  NOT: [SensorWhereInput!]
}

input SensorWhereUniqueInput {
  id: Int
}

type Subscription {
  controller(where: ControllerSubscriptionWhereInput): ControllerSubscriptionPayload
  controllersState(where: ControllersStateSubscriptionWhereInput): ControllersStateSubscriptionPayload
  device(where: DeviceSubscriptionWhereInput): DeviceSubscriptionPayload
  mode(where: ModeSubscriptionWhereInput): ModeSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  roomsDevice(where: RoomsDeviceSubscriptionWhereInput): RoomsDeviceSubscriptionPayload
  scenario(where: ScenarioSubscriptionWhereInput): ScenarioSubscriptionPayload
  sensor(where: SensorSubscriptionWhereInput): SensorSubscriptionPayload
  sensorsLog(where: SensorsLogSubscriptionWhereInput): SensorsLogSubscriptionPayload
  sensorsState(where: SensorsStateSubscriptionWhereInput): SensorsStateSubscriptionPayload
}
`